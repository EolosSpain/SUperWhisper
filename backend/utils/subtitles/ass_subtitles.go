package subtitles

import (
	"fmt"
	"strings"
	"time"

	"github.com/duke-git/lancet/v2/slice"
	"github.com/pluja/anysub/models"
)

var (
	assColors = []string{
		"0000FF00",
		"0033FFFF",
		"006666FF",
		"00FF99FF",
		"00FF3399",
		"00FFFF33",
		"00CCFF99",
		"00FFCC5E",
	}
)

func GenerateSubsASS(t models.TranscriptionResult, c SubtitleConfig) string {
	var assBuilder strings.Builder

	assBuilder.WriteString("[Script Info]\n")
	assBuilder.WriteString("; Script generated by AnySub\n")
	assBuilder.WriteString("ScriptType: v4.00+\n")
	assBuilder.WriteString("PlayResX: 384\n")   // Customize as needed
	assBuilder.WriteString("PlayResY: 288\n\n") // Customize as needed

	assBuilder.WriteString("[V4+ Styles]\n")
	assBuilder.WriteString("Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n")

	if c.ColorizeSpeakers {
		addAssSpeakersStyle(&assBuilder, t, c.SpeakerColors)
	}

	assBuilder.WriteString("\n[Events]\n")
	assBuilder.WriteString("Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n")

	buildAssWordSubtitles(&assBuilder, t, c)

	return assBuilder.String()
}

func buildAssWordSubtitles(b *strings.Builder, t models.TranscriptionResult, c SubtitleConfig) {
	var currentSpeaker string
	var cueWords []string
	var cueCharsCount int
	var startTime, endTime float64

	for _, segment := range t.Segments {
		for _, word := range segment.Words {
			startTime, endTime = prepareAssCueTransitions(currentSpeaker, word, cueCharsCount, &cueWords, startTime, &cueCharsCount, c.MaxLengthChars, b)

			currentSpeaker = word.Speaker
			cueWords = append(cueWords, word.Word)
			cueCharsCount += len(word.Word) + 1
		}
	}

	// If we have any remaining words for the last cue, write them out
	if len(cueWords) > 0 {
		endTime = t.Segments[len(t.Segments)-1].Words[len(t.Segments[len(t.Segments)-1].Words)-1].End
		writeAssCue(b, startTime, endTime, currentSpeaker, cueWords)
	}
}

func prepareAssCueTransitions(currentSpeaker string, word models.WordData, cueCharsCount int, cueWords *[]string, startTime float64, cueCharsCombined *int, maxLenChars int, b *strings.Builder) (float64, float64) {
	endTime := word.End

	if word.Speaker != currentSpeaker && currentSpeaker != "" || cueCharsCount+len(word.Word)+1 > maxLenChars {
		writeAssCue(b, startTime, word.Start, currentSpeaker, *cueWords)
		*cueWords = []string{}
		*cueCharsCombined = 0
		startTime = word.Start
	}

	return startTime, endTime
}

func writeAssCue(b *strings.Builder, startTime, endTime float64, speaker string, words []string) {
	cueText := strings.Join(words, " ")
	b.WriteString(fmt.Sprintf("Dialogue: 0,%s,%s,%s,,0,0,0,,%s\n",
		formatASSTime(startTime),
		formatASSTime(endTime),
		speaker,
		cueText,
	))
}

func addAssSpeakersStyle(b *strings.Builder, t models.TranscriptionResult, customColors map[string]string) {
	colrs := assColors
	speakerStyles := make(map[string]string)
	for _, segment := range t.Segments {
		for _, word := range segment.Words {
			if _, ok := speakerStyles[word.Speaker]; !ok && word.Speaker != "" {
				color, ci := slice.Random(colrs)
				colrs = slice.DeleteAt(colrs, ci)
				if customColor, ok := customColors[word.Speaker]; ok {
					color = customColor
				}
				speakerStyles[word.Speaker] = color
				b.WriteString(fmt.Sprintf("Style: %s,Arial,20,&H%s,&HFFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,0\n", word.Speaker, color))
			}
		}
	}
}

func formatASSTime(seconds float64) string {
	t := time.Duration(seconds * float64(time.Second))
	hours := int(t / time.Hour)
	t -= time.Duration(hours) * time.Hour
	minutes := int(t / time.Minute)
	t -= time.Duration(minutes) * time.Minute
	sec := int(t / time.Second)
	t -= time.Duration(sec) * time.Second
	milliseconds := int(t / time.Millisecond)

	return fmt.Sprintf("%d:%02d:%02d.%02d", hours, minutes, sec, milliseconds/10)
}
