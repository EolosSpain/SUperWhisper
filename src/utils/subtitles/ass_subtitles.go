package subtitles

import (
	"fmt"
	"strings"
	"time"

	"github.com/duke-git/lancet/v2/slice"
	"github.com/pluja/anysub/models"
	"github.com/pluja/anysub/utils"
)

var (
	assColors = []string{
		"0000FF00",
		"0033FFFF",
		"006666FF",
		"00FF99FF",
		"00FF3399",
		"00FFFF33",
		"00CCFF99",
		"00FFCC5E",
	}
)

func GenerateSubsASS(t models.TranscriptionResult, c SubtitleConfig) string {
	var assBuilder strings.Builder

	assBuilder.WriteString("[Script Info]\n")
	assBuilder.WriteString("; Script generated by AnySub\n")
	assBuilder.WriteString("ScriptType: v4.00+\n")
	assBuilder.WriteString("PlayResX: 384\n")   // Customize as needed
	assBuilder.WriteString("PlayResY: 288\n\n") // Customize as needed

	assBuilder.WriteString("[V4+ Styles]\n")
	assBuilder.WriteString("Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n")

	if c.ColorizeSpeakers {
		addAssSpeakersStyle(&assBuilder, t, c.SpeakerColors)
	}

	assBuilder.WriteString("\n[Events]\n")
	assBuilder.WriteString("Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n")

	buildAssWordSubtitles(&assBuilder, t, c)

	return assBuilder.String()
}

func buildAssWordSubtitles(b *strings.Builder, t models.TranscriptionResult, c SubtitleConfig) {
	cueCounter := 1
	var currentSpeaker string
	cueWords := make([]string, 0)
	cueCharsCount := 0
	var startTime, endTime, prevWordEndTime float64
	lastWordHadPunctuation := false
	spaceLen := len(" ")
	delay := float64(c.MsDelay) / 1000

	for _, segment := range t.Segments {
		for i, word := range segment.Words {
			wordStartWithDelay := word.Start + delay

			timeGap := word.Start - prevWordEndTime

			newCueNeeded := word.Speaker != currentSpeaker && currentSpeaker != "" ||
				cueCharsCount+len(word.Word)+spaceLen > c.MaxLengthChars ||
				lastWordHadPunctuation ||
				(i > 0 && timeGap > float64(c.MaxTimeGap))

			if newCueNeeded {
				endTime = prevWordEndTime + delay
				writeAssCue(b, startTime, endTime, currentSpeaker, cueWords)
				cueCounter++
				cueWords = []string{word.Word}
				cueCharsCount = len(word.Word) + spaceLen
				startTime = wordStartWithDelay
			} else {
				cueWords = append(cueWords, word.Word)
				cueCharsCount += len(word.Word) + spaceLen
			}

			currentSpeaker = word.Speaker
			endTime = word.End + delay
			prevWordEndTime = word.End
			lastWordHadPunctuation = utils.ContainsPunctuation(word.Word)
		}
	}

	if len(cueWords) > 0 {
		writeAssCue(b, startTime, endTime, currentSpeaker, cueWords)
	}
}

func writeAssCue(b *strings.Builder, startTime, endTime float64, speaker string, words []string) {
	cueText := strings.Join(words, " ")
	b.WriteString(fmt.Sprintf("Dialogue: 0,%s,%s,%s,,0,0,0,,%s\n",
		formatASSTime(startTime),
		formatASSTime(endTime),
		speaker,
		cueText,
	))
}

func addAssSpeakersStyle(b *strings.Builder, t models.TranscriptionResult, customColors map[string]string) {
	colrs := assColors
	speakerStyles := make(map[string]string)
	for _, segment := range t.Segments {
		for _, word := range segment.Words {
			if _, ok := speakerStyles[word.Speaker]; !ok && word.Speaker != "" {
				color, ci := slice.Random(colrs)
				colrs = slice.DeleteAt(colrs, ci)
				if customColor, ok := customColors[word.Speaker]; ok {
					color = customColor
				}
				speakerStyles[word.Speaker] = color
				b.WriteString(fmt.Sprintf("Style: %s,Arial,20,&H%s,&HFFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,0\n", word.Speaker, color))
			}
		}
	}
}

func formatASSTime(seconds float64) string {
	t := time.Duration(seconds * float64(time.Second))
	hours := int(t / time.Hour)
	t -= time.Duration(hours) * time.Hour
	minutes := int(t / time.Minute)
	t -= time.Duration(minutes) * time.Minute
	sec := int(t / time.Second)
	t -= time.Duration(sec) * time.Second
	milliseconds := int(t / time.Millisecond)

	return fmt.Sprintf("%d:%02d:%02d.%02d", hours, minutes, sec, milliseconds/10)
}
